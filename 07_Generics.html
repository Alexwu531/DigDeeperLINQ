<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>變來變去的Generic Type: 泛型介紹 | 深入探索 LINQ</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/DigDeeperLINQ/assets/css/0.styles.d7374936.css" as="style"><link rel="preload" href="/DigDeeperLINQ/assets/js/app.a2b9c658.js" as="script"><link rel="preload" href="/DigDeeperLINQ/assets/js/19.9a74edc6.js" as="script"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/10.05d50042.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/11.d5292423.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/12.efd10669.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/13.77504686.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/14.fd3e6aa6.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/15.2bdb0b8a.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/16.7e9febb0.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/17.6f48564a.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/18.283b68f8.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/2.cf1c94c7.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/20.26d6877e.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/21.05cf0ea3.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/22.b5e0af87.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/23.eae333c6.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/24.f0357f60.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/25.bc1e83ca.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/26.8329651e.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/27.999ff4c8.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/28.c4d765e7.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/29.19452a1e.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/3.e76eb854.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/30.160a9a4d.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/31.0056cbed.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/32.fb712cab.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/33.85d5a0b9.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/34.65a63b5d.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/4.93af7f1b.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/5.1f84db22.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/6.020a9bf3.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/7.ae02f515.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/8.8be7dbe1.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/9.5d617883.js">
    <link rel="stylesheet" href="/DigDeeperLINQ/assets/css/0.styles.d7374936.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/DigDeeperLINQ/" class="home-link router-link-active"><!----> <span class="site-name">深入探索 LINQ</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/DigDeeperLINQ/" class="sidebar-link">目錄</a></li><li><a href="/DigDeeperLINQ/01_Preface.html" class="sidebar-link">踏上探索的旅途: 前言</a></li><li><a href="/DigDeeperLINQ/02_Prepare.html" class="sidebar-link">探索的準備: 使用工具及說明</a></li><li><a href="/DigDeeperLINQ/03_LINQPad.html" class="sidebar-link">每個.NET工程師都要有的一隻箭: LINQPad介紹</a></li><li><a href="/DigDeeperLINQ/04_foreach.html" class="sidebar-link">藏在foreach下的秘密: foreach原理說明</a></li><li><a href="/DigDeeperLINQ/05_yield.html" class="sidebar-link">仔細體會yield的甜美: yield介紹</a></li><li><a href="/DigDeeperLINQ/06_Lambda.html" class="sidebar-link">Lambda運算式介紹</a></li><li><a href="/DigDeeperLINQ/07_Generics.html" class="active sidebar-link">變來變去的Generic Type: 泛型介紹</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/DigDeeperLINQ/07_Generics.html#箱子工廠" class="sidebar-link">箱子工廠</a></li><li class="sidebar-sub-header"><a href="/DigDeeperLINQ/07_Generics.html#泛型方法介紹" class="sidebar-link">泛型方法介紹</a></li><li class="sidebar-sub-header"><a href="/DigDeeperLINQ/07_Generics.html#結語" class="sidebar-link">結語</a></li><li class="sidebar-sub-header"><a href="/DigDeeperLINQ/07_Generics.html#範例程式" class="sidebar-link">範例程式</a></li><li class="sidebar-sub-header"><a href="/DigDeeperLINQ/07_Generics.html#參考" class="sidebar-link">參考</a></li></ul></li><li><a href="/DigDeeperLINQ/08_WhatIsLINQ.html" class="sidebar-link">所以什麼是LINQ?</a></li><li><a href="/DigDeeperLINQ/09_HowToUseSelect.html" class="sidebar-link">Select的應用</a></li><li><a href="/DigDeeperLINQ/10_BuildCoreFX.html" class="sidebar-link">建置dotnet/corefx</a></li><li><a href="/DigDeeperLINQ/11_InsideOfSelect.html" class="sidebar-link">Select的原碼探險</a></li><li><a href="/DigDeeperLINQ/12_HowToUseSelectMany.html" class="sidebar-link">SelectMany的應用</a></li><li><a href="/DigDeeperLINQ/13_InsideOfSelectMany.html" class="sidebar-link">SelectMany的原碼探險</a></li><li><a href="/DigDeeperLINQ/14_HowToUseWhere.html" class="sidebar-link">Where的應用</a></li><li><a href="/DigDeeperLINQ/15_InsideOfWhere.html" class="sidebar-link">Where的原碼探索</a></li><li><a href="/DigDeeperLINQ/16_HowToUseOrderBy.html" class="sidebar-link">LINQ排序語法(OrderBy、OrderByDescending、ThenBy、ThenByDescending)的應用</a></li><li><a href="/DigDeeperLINQ/17_InsideOfOrderBy.html" class="sidebar-link">OrderBy的原碼探索</a></li><li><a href="/DigDeeperLINQ/18_HowToUseGroupBy.html" class="sidebar-link">GroupBy的應用</a></li><li><a href="/DigDeeperLINQ/19_InsideOfGroupBy.html" class="sidebar-link">GroupBy的原碼探索</a></li><li><a href="/DigDeeperLINQ/20_HowToUseJoin.html" class="sidebar-link">Join的應用</a></li><li><a href="/DigDeeperLINQ/21_InsideOfJoin.html" class="sidebar-link">Join的原碼探索</a></li><li><a href="/DigDeeperLINQ/22_HowToUseGroupJoin.html" class="sidebar-link">GroupJoin的應用</a></li><li><a href="/DigDeeperLINQ/23_InsideOfGroupJoin.html" class="sidebar-link">GroupJoin的原碼探索</a></li><li><a href="/DigDeeperLINQ/24_HowToUseSkip.html" class="sidebar-link">Skip的應用</a></li><li><a href="/DigDeeperLINQ/25_InsideOfSkip.html" class="sidebar-link">Skip的原碼探索</a></li><li><a href="/DigDeeperLINQ/26_HowToUseTake.html" class="sidebar-link">Take的應用</a></li><li><a href="/DigDeeperLINQ/27_InsideOfTake.html" class="sidebar-link">Take的原碼探索</a></li><li><a href="/DigDeeperLINQ/28_HowToUseAggregate.html" class="sidebar-link">Aggregate的應用</a></li><li><a href="/DigDeeperLINQ/29_InsideOfAggregate.html" class="sidebar-link">Aggregate的原碼探索</a></li><li><a href="/DigDeeperLINQ/30_End.html" class="sidebar-link">旅程的結尾</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="變來變去的generic-type-泛型介紹"><a href="#變來變去的generic-type-泛型介紹" aria-hidden="true" class="header-anchor">#</a> 變來變去的Generic Type: 泛型介紹</h1> <p>泛型(Generic Type)是一個C#語言的功能，它可以讓你在定義<strong>Class</strong>、<strong>Method</strong>、<strong>Interface</strong>時先不用決定型別，到了要實體化的時候再決定其型別，這在集合的應用(<a href="https://docs.microsoft.com/zh-tw/dotnet/api/system.collections.generic?view=netframework-4.7.1" target="_blank" rel="noopener noreferrer">System.Collections.Generic<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)上更為重要，因為集合通常只是容器而已，只需要訂定巡覽、新增、刪除元素...等的方法，而訂定這些方法並不需要知道元素的型別，管它是字串還是數字，跟容器本身的實作並沒有關係，因此集合用泛型實作是最佳的選擇，而LINQ就是一個集合的應用方法，當然就用到了大量的Generic Type。</p> <h2 id="箱子工廠"><a href="#箱子工廠" aria-hidden="true" class="header-anchor">#</a> 箱子工廠</h2> <p>為了說明泛型的好處，我們來講一間箱子工廠的故事吧。</p> <p>有間箱子工廠平常都是生產正方形的箱子:</p> <div class="language-C# extra-class"><pre class="language-text"><code>class Program
{
    static void Main(string[] args)
    {
        BoxFactory boxFactory = new BoxFactory();
        boxFactory.Start();
    }
}

class BoxFactory
{
    public BoxFactory()
    {
        Console.WriteLine(&quot;這是一間箱子工廠&quot;);
    }

    class SquareBoxMaker
    {
        public SquareBoxMaker()
        {
            Console.WriteLine(&quot;正方形箱子製造機建置完成&quot;);
        }

        public SquareBox GetSquareBox()
        {
            Console.WriteLine(&quot;產生正方形箱子&quot;);
            return new SquareBox();
        }
    }

    public void Start()
    {
        Console.WriteLine(&quot;工廠開始運作&quot;);
        SquareBoxMaker maker = new SquareBoxMaker();
        maker.GetSquareBox();
    }
}
</code></pre></div><p>運作的結果如下:</p> <div class="language- extra-class"><pre class="language-text"><code>/* 
 * 這是一間箱子工廠
 * 工廠開始運作
 * 正方形箱子製造機建置完成
 * 產生正方形箱子
 */
</code></pre></div><p>有一天工廠的老闆接到一個大客戶的訂單，興奮地跑到工廠跟廠長說了這個消息。</p> <p>老闆: 廠長，我剛剛接到一個要生產大量<strong>三角形箱子</strong>的訂單啦~~。</p> <p>廠長: 可是這個客戶它要的是<strong>三角形的箱子</strong>，工廠裡沒這樣的機器阿!!</p> <p>老闆: 這是一個大客戶，沒關係，<strong>多買一台</strong>吧。</p> <p>於是工廠裡就多了一台<strong>製造三角形箱子的機器</strong>:</p> <div class="language-C# extra-class"><pre class="language-text"><code>class BoxFactory
{
    public BoxFactory()
    {
        Console.WriteLine(&quot;這是一間箱子工廠&quot;);
    }
    class SquareBoxMaker
    {
        ...
    }

    class TriangleBoxMaker
    {
        public TriangleBoxMaker()
        {
            Console.WriteLine(&quot;三角形箱子製造機建置完成&quot;);
        }
        public TriangleBox GetTriangleBox()
        {
            Console.WriteLine(&quot;產生三角形箱子&quot;);
            return new TriangleBox();
        }
    }

    public void Start()
    {
        Console.WriteLine(&quot;工廠開始運作&quot;);

        SquareBoxMaker squareBoxMaker = new SquareBoxMaker();
        TriangleBoxMaker triangleBoxMaker = new TriangleBoxMaker();
        squareBoxMaker.GetSquareBox();
        triangleBoxMaker.GetTriangleBox();
    }
}
</code></pre></div><p>現在工廠運作是這樣的:</p> <div class="language-C# extra-class"><pre class="language-text"><code>/*
 * 這是一間箱子工廠
 * 工廠開始運作
 * 正方形箱子製造機建置完成
 * 三角形箱子製造機建置完成
 * 產生正方形箱子
 * 產生三角形箱子
*/
</code></pre></div><p>過了一陣子，公司就接到了一個客戶要做<strong>圓形的箱子</strong>，不過這個客戶的訂單量很少，為了他買一台圓形箱子的製造機並不划算，可是老闆怎麼會錯過這個賺錢的機會呢。</p> <p>於是老闆左思右想終於想到了一個方法: 那我們的工廠就生產個比較大的箱子，這個箱子可以放下各個不同形狀的箱子，這樣不管以後再來多少不一樣的需求我都可以賺錢了阿。</p> <p>廠長聽了老闆的想法後立刻改造了工廠:</p> <div class="language-C# extra-class"><pre class="language-text"><code>class BoxFactory
{
    public BoxFactory()
    {
        Console.WriteLine(&quot;這是一間箱子工廠&quot;);
    }

    class ObjectBoxMaker
    {
        public ObjectBoxMaker()
        {
            Console.WriteLine(&quot;'大'箱子製造機建置完成&quot;);
        }

        public object GetBox(string shape)
        {
            Console.WriteLine(&quot;產生'大'箱子&quot;);
            if (shape == &quot;Triangle&quot;) return new TriangleBox();
            if (shape == &quot;Square&quot;) return new SquareBox();
            return new CircleBox();
        }
    }

    public void Start()
    {
        Console.WriteLine(&quot;工廠開始運作&quot;);
        ObjectBoxMaker maker = new ObjectBoxMaker();
        maker.GetBox(&quot;Square&quot;);
        maker.GetBox(&quot;Triangle&quot;);
        maker.GetBox(&quot;Circle&quot;);
    }
}
</code></pre></div><p>現在工廠的運作狀況變這樣:</p> <div class="language-C# extra-class"><pre class="language-text"><code>/*
 * 這是一間箱子工廠
 * 工廠開始運作
 * '大'箱子製造機建置完成
 * 產生'大'箱子
 * 產生'大'箱子
 * 產生'大'箱子
 */
</code></pre></div><p>又過了一陣子，公司開始接到客戶的抱怨電話: 那個'大'箱子雖然可以容納各種形狀的箱子，但是每次都要打開來<strong>確定它真正的形狀是什麼</strong>，<strong>效率差了一大截</strong>阿。</p> <p>老闆這下子可真慌了手腳了，弄巧成拙，一時之間又想不出辦法，於是只能硬著頭皮去請救兵-<strong>泛型哥</strong>幫忙，泛型哥聽了老闆的說明以後不慌不忙地將工廠改造成這樣:</p> <div class="language-C# extra-class"><pre class="language-text"><code>class SquareBox
{
    public SquareBox()
    {
        Console.WriteLine(&quot;正方形箱子&quot;);
    }
}

class TriangleBox
{
    public TriangleBox()
    {
        Console.WriteLine(&quot;三角形箱子&quot;);
    }
}

class CircleBox
{
    public CircleBox()
    {
        Console.WriteLine(&quot;圓形箱子&quot;);
    }
}

class BoxFactory
{
    public BoxFactory()
    {
        Console.WriteLine(&quot;這是一間箱子工廠&quot;);
    }
    
    class GenericBoxMaker
    {
        public GenericBoxMaker()
        {
            Console.WriteLine(&quot;箱子製造機建置完成&quot;);
        }

        public object GetBox&lt;T&gt;() where T : new()
        {
            Console.WriteLine(&quot;產生合適的箱子&quot;);
            return new T();
        }
    }
    public void Start()
    {
        Console.WriteLine(&quot;工廠開始運作&quot;);
        GenericBoxMaker maker = new GenericBoxMaker();
        maker.GetBox&lt;SquareBox&gt;();
        maker.GetBox&lt;TriangleBox&gt;();
        maker.GetBox&lt;CircleBox&gt;();
    }
}
</code></pre></div><p>現在工廠運作變成這樣:</p> <div class="language-C# extra-class"><pre class="language-text"><code>/*
 * 這是一間箱子工廠
 * 工廠開始運作
 * 箱子製造機建置完成
 * 產生合適的箱子
 * 正方形箱子
 * 產生合適的箱子
 * 三角形箱子
 * 產生合適的箱子
 * 圓形箱子
 */
</code></pre></div><p><strong>泛型</strong>哥完美的解決了公司的危機，這個故事也告一個段落了。</p> <p>接著我們來回顧一下這個故事:</p> <ol><li>特定箱子的製造機: 每個製造機只能產出跟其對應形狀的箱子
<ul><li>在<strong>定義類別時就決定了型別</strong></li></ul></li> <li>大箱子的製造機: 此製造機所產出的箱子(Object)是相容於每個不同形狀的箱子
<ul><li>所有的輸出類別都轉為<code>Object</code>，使其變為<strong>弱型別</strong></li> <li><code>Object</code>在取值及附值時都需要<strong>花費轉換的時間</strong></li></ul></li> <li>泛型哥的製造機: 在定義時使用泛型先<strong>暫緩型別的規格定義</strong>，到了<strong>實體化時再定義其型別規格</strong> <ul><li><strong>強型別</strong></li> <li><strong>不需做轉換</strong></li></ul></li></ol> <h2 id="泛型方法介紹"><a href="#泛型方法介紹" aria-hidden="true" class="header-anchor">#</a> 泛型方法介紹</h2> <p>泛型可以用在很多地方，像是類別、介面、方法...等，規則大同小異，因為LINQ常用的是泛型方法，所以就方法的部分來做介紹:</p> <div class="language-C# extra-class"><pre class="language-text"><code>public T Generic&lt;T&gt;(T b) where T : new()
{
    return new T();
}
</code></pre></div><ul><li>在方法名稱的後面以<code>&lt;&gt;</code>括住待定義的型別參數</li> <li>待定義的型別參數名稱習慣以<code>T</code>開頭(Ex: <code>TResult</code>)</li> <li>泛型可用在<strong>傳入參數</strong>及<strong>回傳值</strong></li> <li>可以以<code>where</code>定義型別參數的條件，以此例來說，<code>where T : new()</code>定義<code>T</code>有建構子，如此一來我們才可以在<code>new T()</code>，請參考<a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters" target="_blank" rel="noopener noreferrer">Microsoft Docs-型別參數的條件約束<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="結語"><a href="#結語" aria-hidden="true" class="header-anchor">#</a> 結語</h2> <p>泛型非常好用，比起Object既是強型別又不用轉換，也比特定型別定義來的有彈性，可以大大減少程式碼的編寫量，又可以寫出可讀性更高的程式，好泛型，不用嗎?</p> <h2 id="範例程式"><a href="#範例程式" aria-hidden="true" class="header-anchor">#</a> 範例程式</h2> <p><a href="https://github.com/peterhpchen/DigDeeperLINQ/tree/07_Generics/demo/07_Generics" target="_blank" rel="noopener noreferrer">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="參考"><a href="#參考" aria-hidden="true" class="header-anchor">#</a> 參考</h2> <ul><li><a href="https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/generics/" target="_blank" rel="noopener noreferrer">Microsoft Docs-泛型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://docs.microsoft.com/zh-tw/dotnet/api/system.collections.generic?view=netframework-4.7.1" target="_blank" rel="noopener noreferrer">Microsoft Docs-System.Collections.Generic<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/DigDeeperLINQ/06_Lambda.html" class="prev">
          Lambda運算式介紹
        </a></span> <span class="next"><a href="/DigDeeperLINQ/08_WhatIsLINQ.html">
          所以什麼是LINQ?
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/DigDeeperLINQ/assets/js/app.a2b9c658.js" defer></script><script src="/DigDeeperLINQ/assets/js/19.9a74edc6.js" defer></script>
  </body>
</html>
