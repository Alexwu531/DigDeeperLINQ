<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>GroupBy的原碼探索 | 深入探索 LINQ</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/DigDeeperLINQ/assets/css/0.styles.d7374936.css" as="style"><link rel="preload" href="/DigDeeperLINQ/assets/js/app.a2b9c658.js" as="script"><link rel="preload" href="/DigDeeperLINQ/assets/js/25.bc1e83ca.js" as="script"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/10.05d50042.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/11.d5292423.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/12.efd10669.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/13.77504686.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/14.fd3e6aa6.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/15.2bdb0b8a.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/16.7e9febb0.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/17.6f48564a.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/18.283b68f8.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/19.9a74edc6.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/2.cf1c94c7.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/20.26d6877e.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/21.05cf0ea3.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/22.b5e0af87.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/23.eae333c6.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/24.f0357f60.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/26.8329651e.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/27.999ff4c8.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/28.c4d765e7.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/29.19452a1e.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/3.e76eb854.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/30.160a9a4d.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/31.0056cbed.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/32.fb712cab.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/33.85d5a0b9.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/34.65a63b5d.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/4.93af7f1b.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/5.1f84db22.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/6.020a9bf3.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/7.ae02f515.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/8.8be7dbe1.js"><link rel="prefetch" href="/DigDeeperLINQ/assets/js/9.5d617883.js">
    <link rel="stylesheet" href="/DigDeeperLINQ/assets/css/0.styles.d7374936.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/DigDeeperLINQ/" class="home-link router-link-active"><!----> <span class="site-name">深入探索 LINQ</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/DigDeeperLINQ/" class="sidebar-link">目錄</a></li><li><a href="/DigDeeperLINQ/01_Preface.html" class="sidebar-link">踏上探索的旅途: 前言</a></li><li><a href="/DigDeeperLINQ/02_Prepare.html" class="sidebar-link">探索的準備: 使用工具及說明</a></li><li><a href="/DigDeeperLINQ/03_LINQPad.html" class="sidebar-link">每個.NET工程師都要有的一隻箭: LINQPad介紹</a></li><li><a href="/DigDeeperLINQ/04_foreach.html" class="sidebar-link">藏在foreach下的秘密: foreach原理說明</a></li><li><a href="/DigDeeperLINQ/05_yield.html" class="sidebar-link">仔細體會yield的甜美: yield介紹</a></li><li><a href="/DigDeeperLINQ/06_Lambda.html" class="sidebar-link">Lambda運算式介紹</a></li><li><a href="/DigDeeperLINQ/07_Generics.html" class="sidebar-link">變來變去的Generic Type: 泛型介紹</a></li><li><a href="/DigDeeperLINQ/08_WhatIsLINQ.html" class="sidebar-link">所以什麼是LINQ?</a></li><li><a href="/DigDeeperLINQ/09_HowToUseSelect.html" class="sidebar-link">Select的應用</a></li><li><a href="/DigDeeperLINQ/10_BuildCoreFX.html" class="sidebar-link">建置dotnet/corefx</a></li><li><a href="/DigDeeperLINQ/11_InsideOfSelect.html" class="sidebar-link">Select的原碼探險</a></li><li><a href="/DigDeeperLINQ/12_HowToUseSelectMany.html" class="sidebar-link">SelectMany的應用</a></li><li><a href="/DigDeeperLINQ/13_InsideOfSelectMany.html" class="sidebar-link">SelectMany的原碼探險</a></li><li><a href="/DigDeeperLINQ/14_HowToUseWhere.html" class="sidebar-link">Where的應用</a></li><li><a href="/DigDeeperLINQ/15_InsideOfWhere.html" class="sidebar-link">Where的原碼探索</a></li><li><a href="/DigDeeperLINQ/16_HowToUseOrderBy.html" class="sidebar-link">LINQ排序語法(OrderBy、OrderByDescending、ThenBy、ThenByDescending)的應用</a></li><li><a href="/DigDeeperLINQ/17_InsideOfOrderBy.html" class="sidebar-link">OrderBy的原碼探索</a></li><li><a href="/DigDeeperLINQ/18_HowToUseGroupBy.html" class="sidebar-link">GroupBy的應用</a></li><li><a href="/DigDeeperLINQ/19_InsideOfGroupBy.html" class="active sidebar-link">GroupBy的原碼探索</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/DigDeeperLINQ/19_InsideOfGroupBy.html#原始碼分析" class="sidebar-link">原始碼分析</a></li><li class="sidebar-sub-header"><a href="/DigDeeperLINQ/19_InsideOfGroupBy.html#測試案例賞析" class="sidebar-link">測試案例賞析</a></li><li class="sidebar-sub-header"><a href="/DigDeeperLINQ/19_InsideOfGroupBy.html#結語" class="sidebar-link">結語</a></li><li class="sidebar-sub-header"><a href="/DigDeeperLINQ/19_InsideOfGroupBy.html#參考" class="sidebar-link">參考</a></li></ul></li><li><a href="/DigDeeperLINQ/20_HowToUseJoin.html" class="sidebar-link">Join的應用</a></li><li><a href="/DigDeeperLINQ/21_InsideOfJoin.html" class="sidebar-link">Join的原碼探索</a></li><li><a href="/DigDeeperLINQ/22_HowToUseGroupJoin.html" class="sidebar-link">GroupJoin的應用</a></li><li><a href="/DigDeeperLINQ/23_InsideOfGroupJoin.html" class="sidebar-link">GroupJoin的原碼探索</a></li><li><a href="/DigDeeperLINQ/24_HowToUseSkip.html" class="sidebar-link">Skip的應用</a></li><li><a href="/DigDeeperLINQ/25_InsideOfSkip.html" class="sidebar-link">Skip的原碼探索</a></li><li><a href="/DigDeeperLINQ/26_HowToUseTake.html" class="sidebar-link">Take的應用</a></li><li><a href="/DigDeeperLINQ/27_InsideOfTake.html" class="sidebar-link">Take的原碼探索</a></li><li><a href="/DigDeeperLINQ/28_HowToUseAggregate.html" class="sidebar-link">Aggregate的應用</a></li><li><a href="/DigDeeperLINQ/29_InsideOfAggregate.html" class="sidebar-link">Aggregate的原碼探索</a></li><li><a href="/DigDeeperLINQ/30_End.html" class="sidebar-link">旅程的結尾</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="groupby的原碼探索"><a href="#groupby的原碼探索" aria-hidden="true" class="header-anchor">#</a> GroupBy的原碼探索</h1> <p>前面一章提到了我們提到了<code>GroupBy</code>的使用方式，LINQ方法提供給我們很多的選擇，讓我們可以在合適的情境下使用這些方法，我們已經會轉動輪子了，現在來看看輪子是怎麼製造出來的吧。</p> <h2 id="原始碼分析"><a href="#原始碼分析" aria-hidden="true" class="header-anchor">#</a> 原始碼分析</h2> <ul><li>Source Code: <a href="https://github.com/dotnet/corefx/blob/master/src/System.Linq/src/System/Linq/Grouping.cs" target="_blank" rel="noopener noreferrer">Grouping.cs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://github.com/dotnet/corefx/blob/master/src/System.Linq/src/System/Linq/Lookup.cs" target="_blank" rel="noopener noreferrer">Lookup.cs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <p><code>GroupBy</code>總共有<strong>8</strong>個公開方法，實作如下面程式碼所示:</p> <div class="language-C# extra-class"><pre class="language-text"><code>#region GroupedEnumerable&lt;TSource, TKey&gt;

public static IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector) =&gt;
    new GroupedEnumerable&lt;TSource, TKey&gt;(source, keySelector, null);

public static IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, IEqualityComparer&lt;TKey&gt; comparer) =&gt;
    new GroupedEnumerable&lt;TSource, TKey&gt;(source, keySelector, comparer);

#endregion GroupedEnumerable&lt;TSource, TKey&gt;

#region GroupedEnumerable&lt;TSource, TKey, TElement&gt;

public static IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, Func&lt;TSource, TElement&gt; elementSelector) =&gt;
    new GroupedEnumerable&lt;TSource, TKey, TElement&gt;(source, keySelector, elementSelector, null);

public static IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, Func&lt;TSource, TElement&gt; elementSelector, IEqualityComparer&lt;TKey&gt; comparer) =&gt;
    new GroupedEnumerable&lt;TSource, TKey, TElement&gt;(source, keySelector, elementSelector, comparer);

#endregion GroupedEnumerable&lt;TSource, TKey, TElement&gt;

#region GroupedResultEnumerable&lt;TSource, TKey, TResult&gt;

public static IEnumerable&lt;TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, Func&lt;TKey, IEnumerable&lt;TSource&gt;, TResult&gt; resultSelector) =&gt;
    new GroupedResultEnumerable&lt;TSource, TKey, TResult&gt;(source, keySelector, resultSelector, null);

public static IEnumerable&lt;TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, Func&lt;TKey, IEnumerable&lt;TSource&gt;, TResult&gt; resultSelector, IEqualityComparer&lt;TKey&gt; comparer) =&gt;
    new GroupedResultEnumerable&lt;TSource, TKey, TResult&gt;(source, keySelector, resultSelector, comparer);

#endregion GroupedResultEnumerable&lt;TSource, TKey, TResult&gt;

#region GroupedResultEnumerable&lt;TSource, TKey, TElement, TResult&gt;

public static IEnumerable&lt;TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, Func&lt;TSource, TElement&gt; elementSelector, Func&lt;TKey,IEnumerable&lt;TElement&gt;, TResult&gt; resultSelector) =&gt;
    new GroupedResultEnumerable&lt;TSource, TKey, TElement, TResult&gt;(source, keySelector, elementSelector, resultSelector, null);

public static IEnumerable&lt;TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, Func&lt;TSource, TElement&gt; elementSelector, Func&lt;TKey,IEnumerable&lt;TElement&gt;, TResult&gt; resultSelector, IEqualityComparer&lt;TKey&gt; comparer) =&gt;
    new GroupedResultEnumerable&lt;TSource, TKey, TElement, TResult&gt;(source, keySelector, elementSelector, resultSelector, comparer);

#endregion GroupedResultEnumerable&lt;TSource, TKey, TElement, TResult&gt;
</code></pre></div><p>我已經有用<code>#region</code>做了一些整理，它們其實只是分別<code>new</code>出四個不同但是相似的類別，列在下面的是它們的名字及建構子的參數:</p> <ul><li><code>GroupedEnumerable&lt;TSource, TKey&gt;</code> <ol><li><code>IEnumerable&lt;TSource&gt; source</code>: 欲做分組的<strong>資料來源</strong></li> <li><code>Func&lt;TSource, TKey&gt; keySelector</code>: 分組的<strong>鍵值</strong></li> <li><code>IEqualityComparer&lt;TKey&gt; comparer</code>: 比較鍵值是否相同的<strong>等值比較器</strong></li></ol></li> <li><code>GroupedEnumerable&lt;TSource, TKey, TElement&gt;</code> <ol><li><code>IEnumerable&lt;TSource&gt; source</code>: <em>欲做分組的資料來源</em></li> <li><code>Func&lt;TSource, TKey&gt; keySelector</code>: <em>分組的鍵值</em></li> <li><code>Func&lt;TSource, TElement&gt; elementSelector</code>: 每個<strong>元素的輸出資料</strong></li> <li><code>IEqualityComparer&lt;TKey&gt; comparer</code>: <em>比較鍵值是否相同的等值比較器</em></li></ol></li> <li><code>GroupedResultEnumerable&lt;TSource, TKey, TResult&gt;</code> <ol><li><code>IEnumerable&lt;TSource&gt; source</code>: <em>欲做分組的資料來源</em></li> <li><code>Func&lt;TSource, TKey&gt; keySelector</code>: <em>分組的鍵值</em></li> <li><code>Func&lt;TKey, IEnumerable&lt;TSource&gt;, TResult&gt; resultSelector</code>: 每個<strong>組別的輸出資料</strong></li> <li><code>IEqualityComparer&lt;TKey&gt; comparer</code>: <em>比較鍵值是否相同的等值比較器</em></li></ol></li> <li><code>GroupedResultEnumerable&lt;TSource, TKey, TElement, TResult&gt;</code> <ol><li><code>IEnumerable&lt;TSource&gt; source</code>: <em>欲做分組的資料來源</em></li> <li><code>Func&lt;TSource, TKey&gt; keySelector</code>: <em>分組的鍵值</em></li> <li><code>Func&lt;TSource, TElement&gt; elementSelector</code>: 每個<strong>元素的輸出給resultSelector的資料</strong></li> <li><code>Func&lt;TKey, IEnumerable&lt;TElement&gt;, TResult&gt; resultSelector</code>: <em>每個組別的輸出資料</em></li> <li><code>IEqualityComparer&lt;TKey&gt; comparer</code>: <em>比較鍵值是否相同的等值比較器</em></li></ol></li></ul> <p>這裡我盡量清楚的表示每個方法的差異:</p> <ul><li><em>斜體字</em>代表上面一組有的參數，</li> <li><strong>粗體字</strong>表示這個類別多的參數</li></ul> <p>看了這麼多的類別，看的都眼花撩亂了，但是其實它們都是很相似的類別，因此我們就挑一個最複雜的<code>GroupedResultEnumerable&lt;TSource, TKey, TElement, TResult&gt;</code>來看吧。</p> <h3 id="groupedresultenumerable-tsource-tkey-telement-tresult"><a href="#groupedresultenumerable-tsource-tkey-telement-tresult" aria-hidden="true" class="header-anchor">#</a> GroupedResultEnumerable&lt;TSource, TKey, TElement, TResult&gt;</h3> <p>此類別目標如下:</p> <blockquote><p>將資料來源(<code>source</code>)用比較器(<code>comparer</code>)將鍵值(<code>keySelector</code>)分組，再將分組的每個元素用<code>elementSelector</code>取得資料丟到<code>resultSelector</code>中輸出結果。</p></blockquote> <p>知道這個類別要做什麼之後，我們先從建構子看起，實作如下:</p> <div class="language-C# extra-class"><pre class="language-text"><code>public GroupedResultEnumerable(IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, Func&lt;TSource, TElement&gt; elementSelector, Func&lt;TKey, IEnumerable&lt;TElement&gt;, TResult&gt; resultSelector, IEqualityComparer&lt;TKey&gt; comparer)
{
    _source = source ?? throw Error.ArgumentNull(nameof(source));
    _keySelector = keySelector ?? throw Error.ArgumentNull(nameof(keySelector));
    _elementSelector = elementSelector ?? throw Error.ArgumentNull(nameof(elementSelector));
    _comparer = comparer;
    _resultSelector = resultSelector ?? throw Error.ArgumentNull(nameof(resultSelector));
}
</code></pre></div><ul><li>判斷傳入參數(<code>source</code>、<code>keySelector</code>、<code>elementSelector</code>、<code>resultSelector</code>)是否為空，空的話拋出<code>ArgumentNull</code>例外</li></ul> <p>建構子就是單純的檢查參數是否合法，接著我們要來看什麼方法相信大家應該猜到了，沒錯，就是當你看到<code>Enumerable</code>時就會想到的<code>GetEnumerator()</code>:</p> <div class="language-C# extra-class"><pre class="language-text"><code>public IEnumerator&lt;TResult&gt; GetEnumerator()
{
    Lookup&lt;TKey, TElement&gt; lookup = Lookup&lt;TKey, TElement&gt;.Create(_source, _keySelector, _elementSelector, _comparer);
    return lookup.ApplyResultSelector(_resultSelector).GetEnumerator();
}
</code></pre></div><p>在<code>GetEnumerator()</code>中我們可以看到它去<code>Create</code>了一個<code>Lookup</code>的實體，看來得把<code>GroupedResultEnumerable</code>先擺在一邊了，我們先來看看<code>Lookup</code>到底做了什麼吧。</p> <h3 id="lookup-tkey-telement"><a href="#lookup-tkey-telement" aria-hidden="true" class="header-anchor">#</a> Lookup&lt;TKey, TElement&gt;</h3> <p>首先來看剛剛<code>GroupedResultEnumerable</code>叫用的<code>Create</code>方法:</p> <div class="language-C# extra-class"><pre class="language-text"><code>internal static Lookup&lt;TKey, TElement&gt; Create&lt;TSource&gt;(IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, Func&lt;TSource, TElement&gt; elementSelector, IEqualityComparer&lt;TKey&gt; comparer)
{
    Debug.Assert(source != null);
    Debug.Assert(keySelector != null);
    Debug.Assert(elementSelector != null);

    Lookup&lt;TKey, TElement&gt; lookup = new Lookup&lt;TKey, TElement&gt;(comparer);
    foreach (TSource item in source)
    {
        lookup.GetGrouping(keySelector(item), create: true).Add(elementSelector(item));
    }

    return lookup;
}
</code></pre></div><p>這個<code>Create</code>方法有幾個看點:</p> <ol><li>新建了一個<code>Lookup</code>的實體
<ul><li>如果沒有設定<code>comparer</code>的話，用預設(<code>Default</code>)的比較器</li> <li>新建存放<code>Grouping</code>的陣列，預設大小為<strong>7</strong></li></ul></li></ol> <div class="language-C# extra-class"><pre class="language-text"><code>private Lookup(IEqualityComparer&lt;TKey&gt; comparer)
{
    _comparer = comparer ?? EqualityComparer&lt;TKey&gt;.Default;
    _groupings = new Grouping&lt;TKey, TElement&gt;[7];
}
</code></pre></div><ol start="2"><li>對<code>source</code>集合中每一個元素做兩個階段的處理
<ol><li>取得此元素所在的組別</li> <li>將此元素的資料加到上一階段取得的組別中</li></ol></li> <li>傳回已分好組的<code>lookup</code></li></ol> <p>上述這幾個步驟最重要的就是第二步了，我們來看一下第二步的兩個階段到底做了什麼，先來看<code>GetGrouping</code>是如何<strong>取得此元素所在的組別</strong>的。</p> <p>在看這段程式碼前我們先回想一下<code>GroupBy</code>回傳的是什麼? 是一個<code>Grouping</code>的集合，每個Grouping內有一個鍵值及其對應的元素組合，在<code>GetGrouping</code>中就是要找出目前巡覽到的元素鍵值所在的<code>Grouping</code>。</p> <p>知道了<code>GetGrouping</code>目的後，我們來看一下他的定義:</p> <div class="language-C# extra-class"><pre class="language-text"><code>internal Grouping&lt;TKey, TElement&gt; GetGrouping(TKey key, bool create)
</code></pre></div><p><code>GetGrouping</code>這裡我們分兩個部份說，可以看到<code>GetGrouping</code>有兩個參數，第二個參數的<code>create</code>是在<code>Lookup&lt;TKey, TElement&gt;.Create()</code>時才會設為<code>true</code>，這也就是說<code>GetGrouping</code>本身有兩個執行邏輯:</p> <ol><li>兩種執行邏輯都會先取得傳入鍵值的<code>HashCode</code> <ol><li>叫用<code>InternalGetHashCode()</code>取得鍵值<code>HashCode</code></li> <li>叫用客製的比較器(<code>_comparer</code>)做取得<code>HashCode</code>的處理(如果客製比較器沒有設定是使用<code>Default</code>比較器)</li></ol></li></ol> <div class="language-C# extra-class"><pre class="language-text"><code>private int InternalGetHashCode(TKey key)
{
    // Handle comparer implementations that throw when passed null
    return (key == null) ? 0 : _comparer.GetHashCode(key) &amp; 0x7FFFFFFF; // 1.ii
}
...
internal Grouping&lt;TKey, TElement&gt; GetGrouping(TKey key, bool create)
{
    int hashCode = InternalGetHashCode(key);    // 1.i
    ...
}
</code></pre></div><ol start="2"><li><code>create==false</code>: 取得目前<code>_groupings</code>中相同鍵值的<code>grouping</code>回傳，如果在<code>_groupings</code>中找不到相同鍵值的<code>grouping</code>就回傳<code>null</code> <ol><li>比對是否已有相同鍵值的<code>grouping</code>存在</li> <li>比對方式: 先比對<code>hashCode</code>，<code>hashCode</code>相同再用<code>Equals</code>比對</li> <li>有相同鍵值的<code>grouping</code>則回傳此<code>grouping</code></li> <li>沒有的話則傳回<code>null</code></li></ol></li></ol> <div class="language-C# extra-class"><pre class="language-text"><code>internal Grouping&lt;TKey, TElement&gt; GetGrouping(TKey key, bool create)
{
    ...
    for (Grouping&lt;TKey, TElement&gt; g = _groupings[hashCode % _groupings.Length]; g != null; g = g._hashNext) // 2.i
    {
        if (g._hashCode == hashCode &amp;&amp; _comparer.Equals(g._key, key))   // 2.ii
        {
            // 2.iii
            return g;
        }
    }
    ...
    return null;    // 2.iv
}
</code></pre></div><ol start="3"><li><code>create==true</code>: 在新增模式下如果第二步沒有找到相應的<code>grouping</code>的話，則新增一個
<ol><li>判斷是否為<strong>新增模式</strong></li> <li>新增此鍵值的<code>Grouping</code></li> <li>加進<code>_groupings</code>中，讓之後的查找找得到</li> <li>回傳<code>grouping</code></li></ol></li></ol> <div class="language-C# extra-class"><pre class="language-text"><code>internal Grouping&lt;TKey, TElement&gt; GetGrouping(TKey key, bool create)
{
    ...
    if (create) // 3.i
    {
        if (_count == _groupings.Length)
        {
            Resize();
        }

        int index = hashCode % _groupings.Length;
        Grouping&lt;TKey, TElement&gt; g = new Grouping&lt;TKey, TElement&gt;();    // 3.ii
        g._key = key;
        g._hashCode = hashCode;
        g._elements = new TElement[1];
        g._hashNext = _groupings[index];
        _groupings[index] = g;  // 3.iii
        if (_lastGrouping == null)
        {
            g._next = g;
        }
        else
        {
            g._next = _lastGrouping._next;
            _lastGrouping._next = g;
        }

        _lastGrouping = g;
        _count++;
        return g;   // 3.iv
    }
    ...
}
</code></pre></div><p>這裡我們會發現<code>index</code>的取法是<code>hashCode % _groupings.Length</code>，還記得剛剛<code>_groupings</code>的預設大小是<strong>7</strong>嗎? 這裡它利用<code>hashCode</code>對陣列長度的餘數來放進對應的位置裡，這樣我就不用<code>new</code>一個很大的陣列來存放各個<code>HashCode</code>的<code>Grouping</code>，也不用說每次都要全部查找才能找到對應的<code>Grouping</code>，是一個解決的好方法。</p> <p>執行完<code>GetGrouping()</code>後我們得到了一個<code>Grouping</code>的物件，這裡面可能已經有元素，因為之前的元素可能跟目前的元素有相同的鍵值，接下來要把目前的元素加到這個<code>Grouping</code>裡面，所以叫用了<code>Grouping</code>的<code>Add</code>方法。</p> <p>現在<code>Lookup.Create()</code>的工作完成了，它把每個元素放進了它該待的<code>Grouping</code>中，然後傳回給<code>GroupedResultEnumerable</code>。</p> <p>還記得上面有說<code>GroupedResultEnumerable</code>是四種<code>Enumerable</code>中最複雜的嗎? 其實介紹到這裡，我們已經把另一個叫<code>GroupedEnumerable</code>的類別要做的事給說完了，因為<code>GroupedEnumerable</code>比<code>GroupedResultEnumerable</code>少了<strong>彙整組內資料</strong>的處理，所以<code>GroupedEnumerable</code>其實在分完<code>Grouping</code>後就已經完成了，那就在這裡先來看看<code>GetEnumerator()</code>是怎麼處理分組資料的:</p> <div class="language-C# extra-class"><pre class="language-text"><code>public IEnumerator&lt;IGrouping&lt;TKey, TElement&gt;&gt; GetEnumerator()
{
    Grouping&lt;TKey, TElement&gt; g = _lastGrouping;
    if (g != null)
    {
        do
        {
            g = g._next;
            yield return g;
        }
        while (g != _lastGrouping);
    }
}
</code></pre></div><ul><li>迴圈將串列中的所有<code>Grouping</code>巡覽</li> <li>每個<code>Grouping</code>都<code>yield return</code></li></ul> <p>這裡很單純地用<code>yield</code>傳回每個<code>Grouping</code>的資料。</p> <p>接著我們要講講<code>GroupedResultEnumerable</code><strong>彙整組內資料</strong>的處理:</p> <div class="language-C# extra-class"><pre class="language-text"><code>public IEnumerator&lt;TResult&gt; GetEnumerator()
{
    // 1. 將元素擺到對應鍵值的Grouping中
    Lookup&lt;TKey, TElement&gt; lookup = Lookup&lt;TKey, TElement&gt;.Create(_source, _keySelector, _elementSelector, _comparer);
    // 2. 彙整組內資料
    return lookup.ApplyResultSelector(_resultSelector).GetEnumerator();
}
</code></pre></div><p>從上面的程式碼可以看到彙整的處理是在<code>ApplyResultSelector</code>中發生的，我們來看一下<code>ApplyResultSelector</code>裡面做了什麼:</p> <div class="language-C# extra-class"><pre class="language-text"><code>public IEnumerable&lt;TResult&gt; ApplyResultSelector&lt;TResult&gt;(Func&lt;TKey, IEnumerable&lt;TElement&gt;, TResult&gt; resultSelector)
{
    Grouping&lt;TKey, TElement&gt; g = _lastGrouping;
    if (g != null)
    {
        do
        {
            g = g._next;
            g.Trim();
            yield return resultSelector(g._key, g._elements);
        }
        while (g != _lastGrouping);
    }
}
</code></pre></div><p>整個流程跟剛剛講到的<code>GetEnumerator()</code>一樣，只差在回傳的是<code>resultSelector</code>處理過後的資料。</p> <h2 id="測試案例賞析"><a href="#測試案例賞析" aria-hidden="true" class="header-anchor">#</a> 測試案例賞析</h2> <h3 id="grouping-ilist-isreadonly"><a href="#grouping-ilist-isreadonly" aria-hidden="true" class="header-anchor">#</a> Grouping_IList_IsReadOnly</h3> <div class="language-C# extra-class"><pre class="language-text"><code>[Fact]
public void Grouping_IList_IsReadOnly()
{
    IEnumerable&lt;IGrouping&lt;bool, int&gt;&gt; oddsEvens = new int[] { 1, 2, 3, 4 }.GroupBy(i =&gt; i % 2 == 0);
    foreach (IList&lt;int&gt; grouping in oddsEvens)
    {
        Assert.True(grouping.IsReadOnly);
    }
}
</code></pre></div><p>前一章我們在說客製比較器的時候有用基偶數的例子，這裡它是直接用<code>keySelector</code>實作。</p> <h3 id="allelementssamekey"><a href="#allelementssamekey" aria-hidden="true" class="header-anchor">#</a> AllElementsSameKey</h3> <div class="language-C# extra-class"><pre class="language-text"><code>[Fact]
public void AllElementsSameKey()
{
    string[] key = { &quot;Tim&quot;, &quot;Tim&quot;, &quot;Tim&quot;, &quot;Tim&quot; };
    int[] scores = { 60, -10, 40, 100 };
    var source = key.Zip(scores, (k, e) =&gt; new Record { Name = k, Score = e });

    AssertGroupingCorrect(key, source, source.GroupBy(e =&gt; e.Name, new AnagramEqualityComparer()), new AnagramEqualityComparer());
}
</code></pre></div><p>這裡看到一個神奇的東西: <code>Zip</code>，它可以把兩個集合合併成一個，太酷了!!</p> <h2 id="結語"><a href="#結語" aria-hidden="true" class="header-anchor">#</a> 結語</h2> <p>要結束之前我們來順一下整個GroupBy的流程:</p> <ol><li><code>GroupBy</code>會去實體化相應的<code>Enumerable</code></li> <li><code>Enumerable</code>會去叫用<code>Lookup.Create()</code>取得分組資料
<ol><li>叫用<code>GetGrouping</code>取得對應鍵值的<code>Grouping</code></li> <li>將元素用<code>Add</code>加入<code>Grouping</code></li></ol></li> <li><code>GroupedEnumerable</code>的<code>GetEnumerator()</code>依序叫用各個<code>Grouping</code></li> <li><code>GroupedResultEnumerable</code>會再叫用<code>ApplyResultSelector</code>彙整資料</li></ol> <h2 id="參考"><a href="#參考" aria-hidden="true" class="header-anchor">#</a> 參考</h2> <p><a href="https://github.com/dotnet/corefx" target="_blank" rel="noopener noreferrer">dotnet/corefx<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/DigDeeperLINQ/18_HowToUseGroupBy.html" class="prev">
          GroupBy的應用
        </a></span> <span class="next"><a href="/DigDeeperLINQ/20_HowToUseJoin.html">
          Join的應用
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/DigDeeperLINQ/assets/js/app.a2b9c658.js" defer></script><script src="/DigDeeperLINQ/assets/js/25.bc1e83ca.js" defer></script>
  </body>
</html>
